"""
Admin routes for block assignment import/export.

Provides endpoints for:
- CSV/Excel import preview
- Import execution
- Quick template creation
- Export to CSV/Excel
"""

from typing import Annotated

from fastapi import APIRouter, Depends, File, Form, HTTPException, UploadFile
from fastapi.responses import StreamingResponse
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.logging import get_logger
from app.core.security import get_admin_user
from app.db.session import get_async_db
from app.models.user import User
from app.schemas.block_assignment_import import (
    BlockAssignmentExportRequest,
    BlockAssignmentImportRequest,
    BlockAssignmentImportResult,
    BlockAssignmentPreviewResponse,
    BlockAssignmentUploadRequest,
    ExportFormat,
    ImportFormat,
    QuickTemplateCreateRequest,
    QuickTemplateCreateResponse,
)
from app.services.block_assignment_export_service import (
    get_block_assignment_export_service,
)
from app.services.block_assignment_import_service import (
    BlockAssignmentImportService,
    get_block_assignment_import_service,
)

router = APIRouter()
logger = get_logger(__name__)


@router.post(
    "/preview",
    response_model=BlockAssignmentPreviewResponse,
    summary="Preview block assignment import",
    description="""
    Upload CSV content or file and get a preview of what will be imported.

    The preview shows:
    - Match status for each row (matched, unknown rotation, unknown resident, duplicate)
    - Confidence scores for fuzzy matches
    - Unknown rotations that need templates created

    **PERSEC**: Resident names are anonymized in the response.
    """,
)
async def preview_block_assignment_import(
    db: Annotated[AsyncSession, Depends(get_async_db)],
    current_user: Annotated[User, Depends(get_admin_user)],
    csv_content: Annotated[str | None, Form(description="CSV content (paste)")] = None,
    file: Annotated[UploadFile | None, File(description="CSV file upload")] = None,
    academic_year: Annotated[
        int | None,
        Form(description="Academic year (auto-detected if not provided)"),
    ] = None,
) -> BlockAssignmentPreviewResponse:
    """Generate import preview from CSV content or file."""
    # Validate input
    if not csv_content and not file:
        raise HTTPException(
            status_code=400,
            detail="Either csv_content or file must be provided",
        )

    # Read file content if provided
    content = csv_content
    if file:
        try:
            raw_content = await file.read()
            content = raw_content.decode("utf-8")
        except UnicodeDecodeError:
            raise HTTPException(
                status_code=400,
                detail="File must be UTF-8 encoded",
            )

    if not content or not content.strip():
        raise HTTPException(
            status_code=400,
            detail="Content is empty",
        )

    # Create request
    request = BlockAssignmentUploadRequest(
        content=content,
        academic_year=academic_year,
        format=ImportFormat.CSV,
    )

    # Generate preview
    service = get_block_assignment_import_service(db)
    preview = await service.preview_import(request)

    logger.info(
        f"Import preview generated by user {current_user.id}: "
        f"{preview.total_rows} rows, {preview.matched_count} matched"
    )

    return preview


@router.post(
    "/import",
    response_model=BlockAssignmentImportResult,
    summary="Execute block assignment import",
    description="""
    Execute import based on a previous preview.

    Options:
    - skip_duplicates: Skip rows that already exist
    - update_duplicates: Update existing assignments instead of skipping
    - row_overrides: Per-row override of duplicate action

    **Atomic**: All changes are committed in a single transaction.
    """,
)
async def execute_block_assignment_import(
    request: BlockAssignmentImportRequest,
    db: Annotated[AsyncSession, Depends(get_async_db)],
    current_user: Annotated[User, Depends(get_admin_user)],
) -> BlockAssignmentImportResult:
    """Execute import from preview."""
    service = get_block_assignment_import_service(db)
    result = await service.execute_import(request)

    logger.info(
        f"Import executed by user {current_user.id}: "
        f"{result.imported_count} imported, {result.updated_count} updated, "
        f"{result.skipped_count} skipped, {result.failed_count} failed"
    )

    return result


@router.post(
    "/templates/quick-create",
    response_model=QuickTemplateCreateResponse,
    summary="Quick-create rotation template",
    description="""
    Create a new rotation template during import.

    Used when an unknown rotation abbreviation is encountered in the preview.
    Creates a minimal template that can be edited later.
    """,
)
async def quick_create_rotation_template(
    request: QuickTemplateCreateRequest,
    db: Annotated[AsyncSession, Depends(get_async_db)],
    current_user: Annotated[User, Depends(get_admin_user)],
) -> QuickTemplateCreateResponse:
    """Create rotation template during import."""
    service = get_block_assignment_import_service(db)

    template = await service.create_quick_template(
        abbreviation=request.abbreviation,
        name=request.name,
        activity_type=request.activity_type,
        leave_eligible=request.leave_eligible,
    )

    logger.info(
        f"Quick template created by user {current_user.id}: "
        f"{template.abbreviation} - {template.name}"
    )

    return QuickTemplateCreateResponse(
        id=template.id,
        abbreviation=template.abbreviation,
        name=template.name,
        activity_type=template.activity_type,
    )


@router.get(
    "/template",
    summary="Download import template",
    description="Download a sample CSV template for block assignment import.",
)
async def download_import_template(
    current_user: Annotated[User, Depends(get_admin_user)],
) -> StreamingResponse:
    """Download CSV template."""
    template_content = """block_number,rotation_abbrev,resident_name
1,HILO,Smith
1,FMC,Jones
1,FMIT,Williams
2,CARDIO,Brown
2,EM,Davis
"""

    def generate():
        yield template_content

    return StreamingResponse(
        generate(),
        media_type="text/csv",
        headers={
            "Content-Disposition": "attachment; filename=block_assignments_template.csv"
        },
    )


@router.post(
    "/export",
    summary="Export block assignments",
    description="""
    Export block assignments to CSV or Excel format.

    **Filters:**
    - academic_year: Required year to export
    - block_numbers: Optional list of specific blocks
    - rotation_ids: Optional list of rotation IDs
    - resident_ids: Optional list of resident IDs

    **Options:**
    - format: csv or xlsx
    - include_pgy_level: Include PGY column
    - include_leave_status: Include leave columns
    - group_by: Optional grouping (block, resident, rotation)

    **Admin-only**: Full names are included (no PERSEC anonymization).
    """,
)
async def export_block_assignments(
    request: BlockAssignmentExportRequest,
    db: Annotated[AsyncSession, Depends(get_async_db)],
    current_user: Annotated[User, Depends(get_admin_user)],
) -> StreamingResponse:
    """Export block assignments to file."""
    service = get_block_assignment_export_service(db)
    file_bytes, filename, content_type = await service.export(request)

    logger.info(
        f"Export generated by user {current_user.id}: "
        f"year={request.academic_year}, format={request.format.value}, "
        f"filename={filename}"
    )

    def generate():
        yield file_bytes

    return StreamingResponse(
        generate(),
        media_type=content_type,
        headers={"Content-Disposition": f"attachment; filename={filename}"},
    )


@router.post(
    "/parse-block-sheet",
    summary="Parse TRIPLER-format block schedule xlsx",
    description="""
    Parse a TRIPLER-format block schedule xlsx file.

    Extracts:
    - Resident rotation assignments (from column A)
    - Absences (LV cells)
    - FMIT weeks (FMIT cells)

    Returns structured data for preview before import.
    """,
)
async def parse_block_sheet(
    db: Annotated[AsyncSession, Depends(get_async_db)],
    current_user: Annotated[User, Depends(get_admin_user)],
    file: Annotated[UploadFile, File(description="Block schedule xlsx file")],
) -> dict:
    """Parse block schedule xlsx and return structured data."""
    from app.services.block_schedule_parser import BlockScheduleParser

    # Validate file type
    if not file.filename or not file.filename.endswith((".xlsx", ".xls")):
        raise HTTPException(
            status_code=400,
            detail="File must be an Excel file (.xlsx or .xls)",
        )

    try:
        # Read file
        file_bytes = await file.read()

        # Parse
        parser = BlockScheduleParser()
        assignments = parser.parse_bytes(file_bytes)

        # Convert to response format
        parsed_assignments = [
            {
                "rotation": a.rotation_template,
                "secondaryRotation": a.secondary_rotation,
                "name": a.person_name,
                "pgyLevel": a.pgy_level,
                "block": a.block_number,
                "role": a.role,
            }
            for a in assignments
        ]

        # Extract block number
        block_number = assignments[0].block_number if assignments else 0

        logger.info(
            f"Parsed block sheet: {len(assignments)} assignments for block {block_number}"
        )

        return {
            "parsed": {
                "assignments": parsed_assignments,
                "absences": [],  # TODO: Extract from daily cells
                "fmitWeeks": [],  # TODO: Extract from daily cells
                "blockNumber": block_number,
                "warnings": [],
            },
            "rawData": [],  # Simplified for now
        }

    except Exception as e:
        logger.error(f"Failed to parse block sheet: {e}")
        raise HTTPException(
            status_code=400,
            detail=f"Failed to parse file: {str(e)}",
        )


@router.post(
    "/import-block-sheet",
    summary="Import parsed block schedule data",
    description="""
    Import block assignments from parsed block schedule data.

    Creates:
    - Block assignments for each resident/rotation pair
    - Absences for LV periods (if provided)
    """,
)
async def import_block_sheet(
    db: Annotated[AsyncSession, Depends(get_async_db)],
    current_user: Annotated[User, Depends(get_admin_user)],
    data: dict,
) -> dict:
    """Import block schedule data to database."""
    service = get_block_assignment_import_service(db)
    await service.load_caches()

    assignments = data.get("assignments", [])
    block_number = data.get("blockNumber", 0)

    # Convert to CSV format for existing import pipeline
    csv_lines = ["resident_name,rotation_name,block_number"]
    for a in assignments:
        name = a.get("name", "").replace('"', '""')
        rotation = a.get("rotation", "").replace('"', '""')
        csv_lines.append(f'"{name}","{rotation}",{block_number}')

    csv_content = "\n".join(csv_lines)

    # Use existing import pipeline
    request = BlockAssignmentUploadRequest(
        content=csv_content,
        format=ImportFormat.CSV,
        academic_year=None,  # Auto-detect
    )

    preview = await service.preview_import(request)

    # Execute import for matched items
    from app.schemas.block_assignment_import import BlockAssignmentImportRequest

    import_request = BlockAssignmentImportRequest(
        preview_id=preview.preview_id,
        academic_year=preview.academic_year,
        update_duplicates=False,
        skip_unknown=True,
        row_overrides={},
    )

    result = await service.execute_import(import_request)

    logger.info(
        f"Block sheet import: {result.imported_count} created, "
        f"{result.skipped_count} skipped, {result.failed_count} failed"
    )

    return {
        "assignmentsCreated": result.imported_count,
        "absencesCreated": 0,  # TODO: Handle absences
        "skipped": result.skipped_count,
        "failed": result.failed_count,
        "errors": result.error_messages,
    }
