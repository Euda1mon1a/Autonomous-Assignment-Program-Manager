"""Schedule draft models for staging workflow.

Provides staging tables for schedule preview and publish operations:
- ScheduleDraft: Tracks draft schedules with publish and rollback capability
- ScheduleDraftAssignment: Staged assignments before commit to live tables
- ScheduleDraftFlag: Flags requiring review before publish (conflicts, ACGME)

Workflow:
1. Solver/manual/swap generates changes → Stage (ScheduleDraftAssignment records)
2. Auto-detect conflicts and ACGME violations → Create flags
3. Review flags (Tier 1 must acknowledge, Tier 2 can override)
4. Publish (commit to assignments table) or Discard
5. Rollback available for published drafts (within 24-hour window)
"""

import enum
from datetime import datetime
from typing import TYPE_CHECKING, List, Optional
from uuid import uuid4

from sqlalchemy import (
    Boolean,
    Column,
    DateTime,
    Enum,
    ForeignKey,
    Integer,
    String,
    Text,
    Date,
    UniqueConstraint,
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship

from app.db.base import Base
from app.db.types import JSONType

if TYPE_CHECKING:
    from app.models.person import Person
    from app.models.rotation_template import RotationTemplate
    from app.models.schedule_run import ScheduleRun
    from app.models.user import User


class ScheduleDraftStatus(str, enum.Enum):
    """Status of a schedule draft."""

    DRAFT = "draft"  # Active draft, accepting changes
    PUBLISHED = "published"  # Published to live tables
    ROLLED_BACK = "rolled_back"  # Published then rolled back
    DISCARDED = "discarded"  # Abandoned without publishing


class DraftSourceType(str, enum.Enum):
    """Source of draft changes."""

    SOLVER = "solver"  # Generated by CP-SAT solver
    MANUAL = "manual"  # Manual edit via UI
    SWAP = "swap"  # Approved swap request
    IMPORT = "import"  # Excel import


class DraftAssignmentChangeType(str, enum.Enum):
    """Type of change in a draft assignment."""

    ADD = "add"  # New assignment
    MODIFY = "modify"  # Modify existing assignment
    DELETE = "delete"  # Delete existing assignment


class DraftFlagType(str, enum.Enum):
    """Types of flags that require review."""

    CONFLICT = "conflict"  # Double-booking or scheduling conflict
    ACGME_VIOLATION = "acgme_violation"  # ACGME compliance issue
    COVERAGE_GAP = "coverage_gap"  # Missing required coverage
    MANUAL_REVIEW = "manual_review"  # Flagged for manual review


class DraftFlagSeverity(str, enum.Enum):
    """Severity level of a flag."""

    ERROR = "error"  # Blocking - must resolve
    WARNING = "warning"  # Should review, can override
    INFO = "info"  # Informational only


class ScheduleDraft(Base):
    """Tracks a draft schedule awaiting publish.

    Each solver run, batch edit, or swap creates/updates a draft.
    Drafts accumulate changes until published or discarded.
    """

    __tablename__ = "schedule_drafts"
    __versioned__ = {}  # Enable audit trail

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid4)
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)
    created_by_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)

    # Scope
    target_block = Column(Integer, nullable=True)
    target_start_date = Column(Date, nullable=False)
    target_end_date = Column(Date, nullable=False)

    # Status
    status = Column(
        Enum(
            ScheduleDraftStatus,
            values_callable=lambda x: [e.value for e in x],
            name="schedule_draft_status",
        ),
        nullable=False,
        default=ScheduleDraftStatus.DRAFT,
    )

    # Source tracking
    source_type = Column(
        Enum(
            DraftSourceType,
            values_callable=lambda x: [e.value for e in x],
            name="draft_source_type",
        ),
        nullable=False,
    )
    source_schedule_run_id = Column(
        UUID(as_uuid=True), ForeignKey("schedule_runs.id"), nullable=True
    )

    # Publish tracking
    published_at = Column(DateTime, nullable=True)
    published_by_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)

    # Archive/rollback
    archived_version_id = Column(UUID(as_uuid=True), nullable=True)
    rollback_available = Column(Boolean, default=True)
    rollback_expires_at = Column(DateTime, nullable=True)
    rolled_back_at = Column(DateTime, nullable=True)
    rolled_back_by_id = Column(
        UUID(as_uuid=True), ForeignKey("users.id"), nullable=True
    )

    # Metadata
    notes = Column(Text, nullable=True)
    change_summary = Column(
        JSONType, nullable=True
    )  # {added: N, modified: N, deleted: N}

    # Flag tracking (for publish gate)
    flags_total = Column(Integer, default=0)
    flags_acknowledged = Column(Integer, default=0)
    override_comment = Column(
        Text, nullable=True
    )  # Required for Tier 1 with unacked flags
    override_by_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)

    # Relationships
    created_by = relationship("User", foreign_keys=[created_by_id])
    published_by = relationship("User", foreign_keys=[published_by_id])
    rolled_back_by = relationship("User", foreign_keys=[rolled_back_by_id])
    override_by = relationship("User", foreign_keys=[override_by_id])
    source_schedule_run = relationship(
        "ScheduleRun", foreign_keys=[source_schedule_run_id]
    )
    assignments = relationship(
        "ScheduleDraftAssignment",
        back_populates="draft",
        cascade="all, delete-orphan",
    )
    flags = relationship(
        "ScheduleDraftFlag",
        back_populates="draft",
        cascade="all, delete-orphan",
    )

    def __repr__(self) -> str:
        return (
            f"<ScheduleDraft {self.id} block={self.target_block} "
            f"status={self.status.value}>"
        )

    @property
    def has_unacknowledged_flags(self) -> bool:
        """Check if there are flags that haven't been acknowledged."""
        return self.flags_total > self.flags_acknowledged

    @property
    def can_publish(self) -> bool:
        """Check if draft is in a publishable state."""
        return self.status == ScheduleDraftStatus.DRAFT


class ScheduleDraftAssignment(Base):
    """A single staged assignment from a draft.

    Stores assignment data with change tracking.
    Not committed to live assignments table until draft is published.
    """

    __tablename__ = "schedule_draft_assignments"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid4)
    draft_id = Column(
        UUID(as_uuid=True),
        ForeignKey("schedule_drafts.id", ondelete="CASCADE"),
        nullable=False,
    )

    # Assignment data (mirrors assignments table)
    person_id = Column(UUID(as_uuid=True), ForeignKey("people.id"), nullable=False)
    assignment_date = Column(Date, nullable=False)
    time_of_day = Column(
        String(10), nullable=False, default="ALL"
    )  # AM/PM or ALL for full day
    activity_code = Column(String(50), nullable=True)
    rotation_id = Column(
        UUID(as_uuid=True), ForeignKey("rotation_templates.id"), nullable=True
    )

    # Change tracking
    change_type = Column(
        Enum(
            DraftAssignmentChangeType,
            values_callable=lambda x: [e.value for e in x],
            name="draft_assignment_change_type",
        ),
        nullable=False,
    )
    existing_assignment_id = Column(
        UUID(as_uuid=True), nullable=True
    )  # For modify/delete

    # After publish - link to created assignment
    created_assignment_id = Column(UUID(as_uuid=True), nullable=True)

    # Relationships
    draft = relationship("ScheduleDraft", back_populates="assignments")
    person = relationship("Person", foreign_keys=[person_id])
    rotation = relationship("RotationTemplate", foreign_keys=[rotation_id])

    __table_args__ = (
        UniqueConstraint(
            "draft_id",
            "person_id",
            "assignment_date",
            "time_of_day",
            name="uq_draft_assignment_slot",
        ),
    )

    def __repr__(self) -> str:
        return (
            f"<ScheduleDraftAssignment {self.person_id} "
            f"{self.assignment_date} {self.time_of_day} {self.change_type.value}>"
        )


class ScheduleDraftFlag(Base):
    """A flag requiring review before publish.

    Auto-generated for conflicts, ACGME violations, coverage gaps.
    Must be acknowledged (or overridden) before Tier 1 can publish.
    """

    __tablename__ = "schedule_draft_flags"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid4)
    draft_id = Column(
        UUID(as_uuid=True),
        ForeignKey("schedule_drafts.id", ondelete="CASCADE"),
        nullable=False,
    )

    # Flag details
    flag_type = Column(
        Enum(
            DraftFlagType,
            values_callable=lambda x: [e.value for e in x],
            name="draft_flag_type",
        ),
        nullable=False,
    )
    severity = Column(
        Enum(
            DraftFlagSeverity,
            values_callable=lambda x: [e.value for e in x],
            name="draft_flag_severity",
        ),
        nullable=False,
    )
    message = Column(Text, nullable=False)

    # Related entities
    assignment_id = Column(
        UUID(as_uuid=True),
        ForeignKey("schedule_draft_assignments.id", ondelete="SET NULL"),
        nullable=True,
    )
    person_id = Column(UUID(as_uuid=True), ForeignKey("people.id"), nullable=True)
    affected_date = Column(Date, nullable=True)

    # Resolution
    acknowledged_at = Column(DateTime, nullable=True)
    acknowledged_by_id = Column(
        UUID(as_uuid=True), ForeignKey("users.id"), nullable=True
    )
    resolution_note = Column(Text, nullable=True)

    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)

    # Relationships
    draft = relationship("ScheduleDraft", back_populates="flags")
    assignment = relationship("ScheduleDraftAssignment", foreign_keys=[assignment_id])
    person = relationship("Person", foreign_keys=[person_id])
    acknowledged_by = relationship("User", foreign_keys=[acknowledged_by_id])

    def __repr__(self) -> str:
        return (
            f"<ScheduleDraftFlag {self.flag_type.value} "
            f"{self.severity.value}: {self.message[:50]}>"
        )

    @property
    def is_acknowledged(self) -> bool:
        """Check if this flag has been acknowledged."""
        return self.acknowledged_at is not None
