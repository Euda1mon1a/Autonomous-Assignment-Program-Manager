"""
Overnight Call Generation Constraint.

This module generates overnight call assignments for Sunday through Thursday.
Friday/Saturday are handled by FMIT mandatory call constraint.

Coverage Schedule:
    - Friday night: FMIT attending (see fmit.py)
    - Saturday night: FMIT attending (see fmit.py)
    - Sunday-Thursday: Generated by this constraint

Exclusions:
    - ADJUNCT faculty (not auto-scheduled)
    - Faculty on FMIT during their FMIT week
    - Faculty in post-FMIT Sunday blocking period
    - Faculty with blocking absences

Classes:
    - OvernightCallGenerationConstraint: Creates call variables and coverage constraints
"""

import logging
from collections import defaultdict
from datetime import date, timedelta
from typing import Any
from uuid import UUID

from app.models.person import FacultyRole

from .base import (
    ConstraintPriority,
    ConstraintResult,
    ConstraintType,
    ConstraintViolation,
    HardConstraint,
    SchedulingContext,
)
from .fmit import get_fmit_week_dates

logger = logging.getLogger(__name__)


def is_overnight_call_night(block_date: date) -> bool:
    """
    Check if date requires overnight call assignment.

    Args:
        block_date: Date to check

    Returns:
        True for Sunday-Thursday (weekday 6, 0, 1, 2, 3)
    """
    return block_date.weekday() in (6, 0, 1, 2, 3)  # Sun=6, Mon-Thu=0-3


class OvernightCallGenerationConstraint(HardConstraint):
    """
    Generates overnight call assignments for Sunday through Thursday nights.

    This is a HARD constraint that ensures exactly one faculty member is
    assigned to overnight call for each eligible night.

    Solver Variables Created:
        call_assignments[(f_i, b_i, "overnight")] = BoolVar

    Hard Rules:
        1. Exactly one faculty assigned per night (Sun-Thurs)
        2. ADJUNCT faculty excluded
        3. FMIT faculty blocked during their FMIT week
        4. Post-FMIT Sunday blocking respected
        5. Absence blocking respected
    """

    def __init__(self) -> None:
        """Initialize overnight call generation constraint."""
        super().__init__(
            name="OvernightCallGeneration",
            constraint_type=ConstraintType.CALL,
            priority=ConstraintPriority.HIGH,
        )

    def _get_eligible_faculty(
        self,
        context: SchedulingContext,
        target_date: date,
        fmit_weeks_by_faculty: dict[UUID, list[tuple[date, date]]],
    ) -> list[tuple[Any, int]]:
        """
        Get faculty eligible for overnight call on a specific date.

        Args:
            context: Scheduling context
            target_date: Date to check eligibility for
            fmit_weeks_by_faculty: Pre-computed FMIT weeks by faculty ID

        Returns:
            List of (faculty, faculty_index) tuples
        """
        eligible = []

        for faculty in context.faculty:
            # Rule 1: Exclude ADJUNCT faculty
            if (
                hasattr(faculty, "role_enum")
                and faculty.role_enum == FacultyRole.ADJUNCT
            ):
                continue
            if hasattr(faculty, "faculty_role") and faculty.faculty_role == "adjunct":
                continue

            f_i = context.resident_idx.get(faculty.id)
            if f_i is None:
                continue

            # Rule 2: Check FMIT blocking
            is_blocked = False
            if faculty.id in fmit_weeks_by_faculty:
                for friday_start, thursday_end in fmit_weeks_by_faculty[faculty.id]:
                    if friday_start <= target_date <= thursday_end:
                        is_blocked = True
                        break

            if is_blocked:
                continue

            # Rule 3: Check post-FMIT Sunday blocking
            if target_date.weekday() == 6:  # Sunday
                if faculty.id in fmit_weeks_by_faculty:
                    for friday_start, thursday_end in fmit_weeks_by_faculty[faculty.id]:
                        blocked_sunday = thursday_end + timedelta(days=3)
                        if target_date == blocked_sunday:
                            is_blocked = True
                            break

            if is_blocked:
                continue

            # Rule 4: Check availability (absences)
            if faculty.id in context.availability:
                for block in context.blocks:
                    if block.date == target_date:
                        block_avail = context.availability[faculty.id].get(block.id, {})
                        if not block_avail.get("available", True):
                            is_blocked = True
                            break

            if is_blocked:
                continue

            eligible.append((faculty, f_i))

        return eligible

    def _identify_fmit_weeks(
        self, context: SchedulingContext
    ) -> dict[UUID, list[tuple[date, date]]]:
        """
        Identify FMIT weeks from existing assignments.

        Returns:
            dict: {faculty_id: [(friday_start, thursday_end), ...]}
        """
        fmit_weeks: dict[UUID, set[tuple[date, date]]] = defaultdict(set)

        for a in context.existing_assignments:
            template = None
            for t in context.templates:
                if t.id == a.rotation_template_id:
                    template = t
                    break

            if not template:
                continue

            is_fmit = (
                hasattr(template, "activity_type")
                and template.activity_type == "inpatient"
                and hasattr(template, "name")
                and "FMIT" in template.name.upper()
            )

            if not is_fmit:
                continue

            block = None
            for b in context.blocks:
                if b.id == a.block_id:
                    block = b
                    break

            if not block:
                continue

            friday_start, thursday_end = get_fmit_week_dates(block.date)
            fmit_weeks[a.person_id].add((friday_start, thursday_end))

        return {k: list(v) for k, v in fmit_weeks.items()}

    def add_to_cpsat(
        self,
        model: Any,
        variables: dict[str, Any],
        context: SchedulingContext,
    ) -> None:
        """
        Add overnight call generation constraints to CP-SAT model.

        Creates decision variables and constraints for call assignments.
        """
        # Initialize call_assignments dict if not present
        if "call_assignments" not in variables:
            variables["call_assignments"] = {}

        call_vars = variables["call_assignments"]
        fmit_weeks = self._identify_fmit_weeks(context)

        # Get unique dates from blocks
        dates = sorted(set(b.date for b in context.blocks))

        # Get overnight call nights
        call_nights = [d for d in dates if is_overnight_call_night(d)]

        if not call_nights:
            return

        for target_date in call_nights:
            # Get eligible faculty for this night
            eligible = self._get_eligible_faculty(context, target_date, fmit_weeks)

            if not eligible:
                logger.warning(
                    f"No eligible faculty for overnight call on {target_date}"
                )
                continue

            # Find block index for this date (use AM block as reference)
            b_i = None
            for block in context.blocks:
                if block.date == target_date and block.time_of_day == "AM":
                    b_i = context.block_idx.get(block.id)
                    break

            if b_i is None:
                # Try any block on this date if no AM block found
                for block in context.blocks:
                    if block.date == target_date:
                        b_i = context.block_idx.get(block.id)
                        break

            if b_i is None:
                continue

            # Create decision variables for each eligible faculty
            night_vars = []
            for faculty, f_i in eligible:
                var = model.NewBoolVar(f"call_{f_i}_{target_date}")
                call_vars[(f_i, b_i, "overnight")] = var
                night_vars.append(var)

            # Constraint: Exactly one faculty takes call each night
            if night_vars:
                model.Add(sum(night_vars) == 1)

    def add_to_pulp(
        self,
        model: Any,
        variables: dict[str, Any],
        context: SchedulingContext,
    ) -> None:
        """Add overnight call generation constraints to PuLP model."""
        import pulp

        if "call_assignments" not in variables:
            variables["call_assignments"] = {}

        call_vars = variables["call_assignments"]
        fmit_weeks = self._identify_fmit_weeks(context)

        dates = sorted(set(b.date for b in context.blocks))
        call_nights = [d for d in dates if is_overnight_call_night(d)]

        if not call_nights:
            return

        constraint_count = 0
        for target_date in call_nights:
            eligible = self._get_eligible_faculty(context, target_date, fmit_weeks)

            if not eligible:
                continue

            b_i = None
            for block in context.blocks:
                if block.date == target_date and block.time_of_day == "AM":
                    b_i = context.block_idx.get(block.id)
                    break

            if b_i is None:
                for block in context.blocks:
                    if block.date == target_date:
                        b_i = context.block_idx.get(block.id)
                        break

            if b_i is None:
                continue

            night_vars = []
            for faculty, f_i in eligible:
                var = pulp.LpVariable(
                    f"call_{f_i}_{target_date}",
                    cat=pulp.LpBinary,
                )
                call_vars[(f_i, b_i, "overnight")] = var
                night_vars.append(var)

            if night_vars:
                model += (
                    pulp.lpSum(night_vars) == 1,
                    f"one_call_per_night_{constraint_count}",
                )
                constraint_count += 1

    def validate(
        self,
        assignments: list[Any],
        context: SchedulingContext,
    ) -> ConstraintResult:
        """Validate overnight call assignments."""
        violations = []
        fmit_weeks = self._identify_fmit_weeks(context)

        # Get unique dates requiring call
        dates = sorted(set(b.date for b in context.blocks))
        call_nights = [d for d in dates if is_overnight_call_night(d)]

        # Build map of call assignments by date
        calls_by_date: dict[date, list[Any]] = defaultdict(list)
        faculty_by_id = {f.id: f for f in context.faculty}

        for a in assignments:
            if not hasattr(a, "call_type") or a.call_type != "overnight":
                continue
            if hasattr(a, "date"):
                calls_by_date[a.date].append(a)

        # Check each night has exactly one call
        for night in call_nights:
            calls = calls_by_date.get(night, [])

            if len(calls) == 0:
                violations.append(
                    ConstraintViolation(
                        constraint_name=self.name,
                        constraint_type=self.constraint_type,
                        severity="CRITICAL",
                        message=f"No overnight call assigned for {night}",
                        details={"date": str(night)},
                    )
                )
            elif len(calls) > 1:
                violations.append(
                    ConstraintViolation(
                        constraint_name=self.name,
                        constraint_type=self.constraint_type,
                        severity="HIGH",
                        message=f"Multiple overnight calls on {night}",
                        details={"date": str(night), "count": len(calls)},
                    )
                )
            else:
                # Validate the assigned faculty is eligible
                call = calls[0]
                faculty = faculty_by_id.get(call.person_id)

                if faculty:
                    # Check ADJUNCT exclusion
                    is_adjunct = False
                    if (
                        hasattr(faculty, "role_enum")
                        and faculty.role_enum == FacultyRole.ADJUNCT
                    ):
                        is_adjunct = True
                    if (
                        hasattr(faculty, "faculty_role")
                        and faculty.faculty_role == "adjunct"
                    ):
                        is_adjunct = True

                    if is_adjunct:
                        faculty_name = getattr(faculty, "name", "Faculty")
                        violations.append(
                            ConstraintViolation(
                                constraint_name=self.name,
                                constraint_type=self.constraint_type,
                                severity="CRITICAL",
                                message=f"ADJUNCT faculty {faculty_name} assigned overnight call on {night}",
                                person_id=faculty.id,
                                details={"date": str(night)},
                            )
                        )

        return ConstraintResult(
            satisfied=len(violations) == 0,
            violations=violations,
        )
