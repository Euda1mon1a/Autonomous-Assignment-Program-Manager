<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N-1/N-2 Contingency Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a0f; font-family: 'Inter', system-ui, sans-serif; }
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }

        .panel {
            background: rgba(10, 10, 20, 0.95);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        .faculty-btn {
            transition: all 0.2s ease;
            position: relative;
        }
        .faculty-btn:hover {
            transform: scale(1.05);
        }
        .faculty-btn.removed {
            opacity: 0.3;
            text-decoration: line-through;
        }
        .faculty-btn .risk-indicator {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #0a0a0f;
        }

        .metric-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 8px;
            padding: 12px;
        }

        .status-healthy { color: #22c55e; }
        .status-warning { color: #eab308; }
        .status-critical { color: #ef4444; }

        .pulse {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 12px;
            pointer-events: none;
            z-index: 100;
            max-width: 250px;
            display: none;
        }
    </style>
</head>
<body>
    <!-- Tooltip -->
    <div id="tooltip" class="tooltip text-white text-sm"></div>

    <!-- Header -->
    <div class="absolute top-4 left-4 z-10">
        <h1 class="text-2xl font-bold text-white">N-1 / N-2 Contingency</h1>
        <p class="text-gray-400 text-sm mt-1">Click faculty to simulate absence. What breaks?</p>
    </div>

    <!-- Faculty Control Panel -->
    <div class="panel absolute top-4 right-4 p-4 w-80 z-10">
        <div class="flex items-center justify-between mb-4">
            <h2 class="text-white font-semibold text-sm uppercase tracking-wider">Faculty (10)</h2>
            <button onclick="resetAll()" class="text-xs text-gray-400 hover:text-white px-2 py-1 rounded bg-white/5 hover:bg-white/10">
                Reset All
            </button>
        </div>

        <div id="faculty-grid" class="grid grid-cols-2 gap-2 mb-4">
            <!-- Faculty buttons generated by JS -->
        </div>

        <div class="border-t border-white/10 pt-4 mt-4">
            <div class="flex gap-2 mb-3">
                <button onclick="setMode('n1')" id="btn-n1" class="flex-1 py-2 px-3 rounded-lg text-xs font-bold uppercase bg-blue-500/20 text-blue-400 border border-blue-500/30">
                    N-1 Mode
                </button>
                <button onclick="setMode('n2')" id="btn-n2" class="flex-1 py-2 px-3 rounded-lg text-xs font-bold uppercase bg-white/5 text-gray-400 border border-white/10">
                    N-2 Mode
                </button>
            </div>
            <p class="text-xs text-gray-500">
                <span id="mode-description">N-1: System must survive loss of any single faculty</span>
            </p>
        </div>
    </div>

    <!-- Metrics Panel -->
    <div class="panel absolute bottom-4 left-4 p-4 w-96 z-10">
        <h2 class="text-white font-semibold text-sm uppercase tracking-wider mb-3">System Health</h2>

        <div class="grid grid-cols-2 gap-3">
            <div class="metric-card">
                <div class="text-xs text-gray-400 mb-1">Coverage Rate</div>
                <div id="metric-coverage" class="text-2xl font-bold status-healthy">100%</div>
            </div>
            <div class="metric-card">
                <div class="text-xs text-gray-400 mb-1">Supervision Gaps</div>
                <div id="metric-gaps" class="text-2xl font-bold status-healthy">0</div>
            </div>
            <div class="metric-card">
                <div class="text-xs text-gray-400 mb-1">Overloaded Faculty</div>
                <div id="metric-overload" class="text-2xl font-bold status-healthy">0</div>
            </div>
            <div class="metric-card">
                <div class="text-xs text-gray-400 mb-1">At-Risk Residents</div>
                <div id="metric-atrisk" class="text-2xl font-bold status-healthy">0</div>
            </div>
        </div>

        <div class="mt-4 p-3 rounded-lg" id="status-banner" style="background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3);">
            <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded-full bg-green-500"></div>
                <span id="status-text" class="text-sm text-green-400 font-medium">System Nominal - Full Redundancy</span>
            </div>
        </div>
    </div>

    <!-- Legend -->
    <div class="panel absolute bottom-4 right-4 p-4 z-10">
        <h3 class="text-xs font-bold text-gray-400 uppercase mb-3 tracking-wider">Legend</h3>
        <div class="space-y-2 text-sm">
            <div class="flex items-center gap-2">
                <div class="w-4 h-4 rounded-full bg-blue-500"></div>
                <span class="text-gray-300">Faculty (Active)</span>
            </div>
            <div class="flex items-center gap-2">
                <div class="w-4 h-4 rounded-full bg-gray-600"></div>
                <span class="text-gray-300">Faculty (Removed)</span>
            </div>
            <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded-full bg-green-500"></div>
                <span class="text-gray-300">Resident (Covered)</span>
            </div>
            <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded-full bg-red-500 pulse"></div>
                <span class="text-gray-300">Resident (Uncovered)</span>
            </div>
            <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded-full bg-yellow-500"></div>
                <span class="text-gray-300">Resident (Backup Only)</span>
            </div>
        </div>
    </div>

    <script>
        // ========== DATA MODEL ==========
        const FACULTY = [
            { id: 'F1', name: 'Dr. Alpha', specialty: 'FM Clinic', capacity: 4, critical: true },
            { id: 'F2', name: 'Dr. Beta', specialty: 'FM Clinic', capacity: 4, critical: false },
            { id: 'F3', name: 'Dr. Gamma', specialty: 'Inpatient', capacity: 3, critical: true },
            { id: 'F4', name: 'Dr. Delta', specialty: 'Inpatient', capacity: 3, critical: false },
            { id: 'F5', name: 'Dr. Epsilon', specialty: 'OB', capacity: 2, critical: true },
            { id: 'F6', name: 'Dr. Zeta', specialty: 'OB', capacity: 2, critical: false },
            { id: 'F7', name: 'Dr. Eta', specialty: 'Peds', capacity: 3, critical: false },
            { id: 'F8', name: 'Dr. Theta', specialty: 'Geriatrics', capacity: 3, critical: false },
            { id: 'F9', name: 'Dr. Iota', specialty: 'Sports Med', capacity: 2, critical: false },
            { id: 'F10', name: 'Dr. Kappa', specialty: 'Urgent Care', capacity: 3, critical: true },
        ];

        const RESIDENTS = [];
        // Generate 24 residents with primary and backup supervisors
        for (let i = 1; i <= 24; i++) {
            const pgyLevel = Math.ceil(i / 8); // PGY1, PGY2, PGY3
            const primaryIdx = (i - 1) % 10;
            let backupIdx = (primaryIdx + 1) % 10;
            // Some residents have same backup as primary's pair
            if (Math.random() > 0.7) backupIdx = (primaryIdx + 2) % 10;

            RESIDENTS.push({
                id: `R${i}`,
                name: `Res. ${String.fromCharCode(64 + i)}`,
                pgy: pgyLevel,
                primary: FACULTY[primaryIdx].id,
                backup: FACULTY[backupIdx].id
            });
        }

        // ========== STATE ==========
        let removedFaculty = new Set();
        let mode = 'n1'; // 'n1' or 'n2'
        let scene, camera, renderer, controls;
        let facultyMeshes = {};
        let residentMeshes = {};
        let connectionLines = [];

        // ========== THREE.JS SETUP ==========
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 25);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2;

            // Lighting
            scene.add(new THREE.AmbientLight(0x404040, 0.5));
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(10, 20, 10);
            scene.add(pointLight);

            // Grid helper
            const grid = new THREE.GridHelper(30, 30, 0x222233, 0x111122);
            scene.add(grid);

            createNodes();
            createConnections();

            window.addEventListener('resize', onResize);

            // Raycaster for hover/click
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            renderer.domElement.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(Object.values(facultyMeshes).concat(Object.values(residentMeshes)));

                const tooltip = document.getElementById('tooltip');
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    if (obj.userData.type === 'faculty') {
                        const f = FACULTY.find(x => x.id === obj.userData.id);
                        const supervised = RESIDENTS.filter(r => r.primary === f.id || r.backup === f.id);
                        tooltip.innerHTML = `
                            <div class="font-bold text-blue-400">${f.name}</div>
                            <div class="text-gray-400 text-xs">${f.specialty} | Capacity: ${f.capacity}</div>
                            <div class="mt-2 text-xs">Supervises ${supervised.length} residents</div>
                            ${f.critical ? '<div class="mt-1 text-red-400 text-xs">CRITICAL NODE</div>' : ''}
                        `;
                    } else if (obj.userData.type === 'resident') {
                        const r = RESIDENTS.find(x => x.id === obj.userData.id);
                        const primary = FACULTY.find(f => f.id === r.primary);
                        const backup = FACULTY.find(f => f.id === r.backup);
                        tooltip.innerHTML = `
                            <div class="font-bold text-green-400">${r.name}</div>
                            <div class="text-gray-400 text-xs">PGY-${r.pgy}</div>
                            <div class="mt-2 text-xs">Primary: ${primary.name}</div>
                            <div class="text-xs">Backup: ${backup.name}</div>
                        `;
                    }
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.clientX + 15) + 'px';
                    tooltip.style.top = (e.clientY + 15) + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            });

            renderer.domElement.addEventListener('click', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(Object.values(facultyMeshes));

                if (intersects.length > 0) {
                    const fid = intersects[0].object.userData.id;
                    toggleFaculty(fid);
                }
            });
        }

        function createNodes() {
            // Faculty in a circle at y=0
            const facultyRadius = 10;
            FACULTY.forEach((f, i) => {
                const angle = (i / FACULTY.length) * Math.PI * 2;
                const x = Math.cos(angle) * facultyRadius;
                const z = Math.sin(angle) * facultyRadius;

                const geometry = new THREE.SphereGeometry(0.8, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x3b82f6,
                    emissive: 0x1e40af,
                    emissiveIntensity: 0.3,
                    metalness: 0.3,
                    roughness: 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, 0, z);
                mesh.userData = { type: 'faculty', id: f.id };
                scene.add(mesh);
                facultyMeshes[f.id] = mesh;
            });

            // Residents in inner rings
            const residentRadius = 5;
            RESIDENTS.forEach((r, i) => {
                const ring = Math.floor(i / 12);
                const posInRing = i % 12;
                const angle = (posInRing / 12) * Math.PI * 2 + (ring * 0.15);
                const radius = residentRadius - ring * 1.5;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                const geometry = new THREE.SphereGeometry(0.4, 16, 16);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x22c55e,
                    emissive: 0x166534,
                    emissiveIntensity: 0.2,
                    metalness: 0.2,
                    roughness: 0.8
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, -0.5, z);
                mesh.userData = { type: 'resident', id: r.id };
                scene.add(mesh);
                residentMeshes[r.id] = mesh;
            });
        }

        function createConnections() {
            // Clear existing
            connectionLines.forEach(l => scene.remove(l));
            connectionLines = [];

            RESIDENTS.forEach(r => {
                const resMesh = residentMeshes[r.id];
                const primaryMesh = facultyMeshes[r.primary];
                const backupMesh = facultyMeshes[r.backup];

                const primaryRemoved = removedFaculty.has(r.primary);
                const backupRemoved = removedFaculty.has(r.backup);

                // Primary connection
                if (!primaryRemoved) {
                    const line = createLine(resMesh.position, primaryMesh.position, 0x3b82f6, 0.8);
                    connectionLines.push(line);
                    scene.add(line);
                }

                // Backup connection (dashed/dimmer)
                if (!backupRemoved && !primaryRemoved) {
                    const line = createLine(resMesh.position, backupMesh.position, 0x6b7280, 0.2);
                    connectionLines.push(line);
                    scene.add(line);
                } else if (!backupRemoved && primaryRemoved) {
                    // Backup becomes active
                    const line = createLine(resMesh.position, backupMesh.position, 0xeab308, 0.8);
                    connectionLines.push(line);
                    scene.add(line);
                }
            });
        }

        function createLine(start, end, color, opacity) {
            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: opacity
            });
            const points = [start.clone(), end.clone()];
            points[0].y += 0.1;
            points[1].y += 0.1;
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            return new THREE.Line(geometry, material);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Pulse uncovered residents
            const time = performance.now() * 0.003;
            RESIDENTS.forEach(r => {
                const mesh = residentMeshes[r.id];
                const primaryGone = removedFaculty.has(r.primary);
                const backupGone = removedFaculty.has(r.backup);

                if (primaryGone && backupGone) {
                    // Uncovered - red pulse
                    mesh.material.color.setHex(0xef4444);
                    mesh.material.emissive.setHex(0x7f1d1d);
                    mesh.scale.setScalar(1 + Math.sin(time) * 0.2);
                } else if (primaryGone) {
                    // Backup only - yellow
                    mesh.material.color.setHex(0xeab308);
                    mesh.material.emissive.setHex(0x713f12);
                    mesh.scale.setScalar(1);
                } else {
                    // Covered - green
                    mesh.material.color.setHex(0x22c55e);
                    mesh.material.emissive.setHex(0x166534);
                    mesh.scale.setScalar(1);
                }
            });

            renderer.render(scene, camera);
        }

        // ========== UI LOGIC ==========
        function renderFacultyGrid() {
            const grid = document.getElementById('faculty-grid');
            grid.innerHTML = FACULTY.map(f => {
                const isRemoved = removedFaculty.has(f.id);
                const riskColor = f.critical ? 'bg-red-500' : 'bg-green-500';
                return `
                    <button
                        onclick="toggleFaculty('${f.id}')"
                        class="faculty-btn p-2 rounded-lg text-left ${isRemoved ? 'removed bg-gray-800' : 'bg-blue-500/20 hover:bg-blue-500/30'}"
                    >
                        <div class="text-xs font-bold ${isRemoved ? 'text-gray-500' : 'text-white'}">${f.name}</div>
                        <div class="text-[10px] ${isRemoved ? 'text-gray-600' : 'text-gray-400'}">${f.specialty}</div>
                        <div class="risk-indicator ${riskColor}"></div>
                    </button>
                `;
            }).join('');
        }

        function toggleFaculty(fid) {
            if (mode === 'n1') {
                // In N-1 mode, only allow one removal at a time
                if (removedFaculty.has(fid)) {
                    removedFaculty.delete(fid);
                } else {
                    removedFaculty.clear();
                    removedFaculty.add(fid);
                }
            } else {
                // In N-2 mode, allow up to 2 removals
                if (removedFaculty.has(fid)) {
                    removedFaculty.delete(fid);
                } else if (removedFaculty.size < 2) {
                    removedFaculty.add(fid);
                }
            }

            updateVisualization();
        }

        function resetAll() {
            removedFaculty.clear();
            updateVisualization();
        }

        function setMode(newMode) {
            mode = newMode;
            removedFaculty.clear();

            document.getElementById('btn-n1').className = mode === 'n1'
                ? 'flex-1 py-2 px-3 rounded-lg text-xs font-bold uppercase bg-blue-500/20 text-blue-400 border border-blue-500/30'
                : 'flex-1 py-2 px-3 rounded-lg text-xs font-bold uppercase bg-white/5 text-gray-400 border border-white/10';
            document.getElementById('btn-n2').className = mode === 'n2'
                ? 'flex-1 py-2 px-3 rounded-lg text-xs font-bold uppercase bg-purple-500/20 text-purple-400 border border-purple-500/30'
                : 'flex-1 py-2 px-3 rounded-lg text-xs font-bold uppercase bg-white/5 text-gray-400 border border-white/10';

            document.getElementById('mode-description').textContent = mode === 'n1'
                ? 'N-1: System must survive loss of any single faculty'
                : 'N-2: System must survive loss of any two faculty';

            updateVisualization();
        }

        function updateVisualization() {
            // Update 3D meshes
            FACULTY.forEach(f => {
                const mesh = facultyMeshes[f.id];
                if (removedFaculty.has(f.id)) {
                    mesh.material.color.setHex(0x374151);
                    mesh.material.emissive.setHex(0x111827);
                    mesh.scale.setScalar(0.6);
                } else {
                    mesh.material.color.setHex(0x3b82f6);
                    mesh.material.emissive.setHex(0x1e40af);
                    mesh.scale.setScalar(1);
                }
            });

            // Rebuild connections
            createConnections();

            // Calculate metrics
            let uncovered = 0;
            let backupOnly = 0;
            let overloadedFaculty = new Set();

            RESIDENTS.forEach(r => {
                const primaryGone = removedFaculty.has(r.primary);
                const backupGone = removedFaculty.has(r.backup);

                if (primaryGone && backupGone) {
                    uncovered++;
                } else if (primaryGone) {
                    backupOnly++;
                    // Check if backup is overloaded
                    const backup = FACULTY.find(f => f.id === r.backup);
                    const backupLoad = RESIDENTS.filter(res =>
                        (res.primary === backup.id && !removedFaculty.has(res.primary)) ||
                        (res.backup === backup.id && removedFaculty.has(res.primary) && !removedFaculty.has(res.backup))
                    ).length;
                    if (backupLoad > backup.capacity) {
                        overloadedFaculty.add(backup.id);
                    }
                }
            });

            const coverage = ((RESIDENTS.length - uncovered) / RESIDENTS.length * 100).toFixed(0);

            // Update UI
            renderFacultyGrid();

            const metricCoverage = document.getElementById('metric-coverage');
            const metricGaps = document.getElementById('metric-gaps');
            const metricOverload = document.getElementById('metric-overload');
            const metricAtrisk = document.getElementById('metric-atrisk');

            metricCoverage.textContent = coverage + '%';
            metricCoverage.className = 'text-2xl font-bold ' + (coverage >= 90 ? 'status-healthy' : coverage >= 70 ? 'status-warning' : 'status-critical');

            metricGaps.textContent = uncovered;
            metricGaps.className = 'text-2xl font-bold ' + (uncovered === 0 ? 'status-healthy' : uncovered <= 2 ? 'status-warning' : 'status-critical');

            metricOverload.textContent = overloadedFaculty.size;
            metricOverload.className = 'text-2xl font-bold ' + (overloadedFaculty.size === 0 ? 'status-healthy' : overloadedFaculty.size <= 1 ? 'status-warning' : 'status-critical');

            metricAtrisk.textContent = backupOnly;
            metricAtrisk.className = 'text-2xl font-bold ' + (backupOnly === 0 ? 'status-healthy' : backupOnly <= 3 ? 'status-warning' : 'status-critical');

            // Status banner
            const banner = document.getElementById('status-banner');
            const statusText = document.getElementById('status-text');

            if (uncovered > 0) {
                banner.style.background = 'rgba(239, 68, 68, 0.1)';
                banner.style.borderColor = 'rgba(239, 68, 68, 0.3)';
                statusText.className = 'text-sm text-red-400 font-medium';
                statusText.textContent = `CRITICAL - ${uncovered} residents without supervision`;
            } else if (backupOnly > 0 || overloadedFaculty.size > 0) {
                banner.style.background = 'rgba(234, 179, 8, 0.1)';
                banner.style.borderColor = 'rgba(234, 179, 8, 0.3)';
                statusText.className = 'text-sm text-yellow-400 font-medium';
                statusText.textContent = `WARNING - Degraded coverage, ${backupOnly} on backup`;
            } else if (removedFaculty.size > 0) {
                banner.style.background = 'rgba(34, 197, 94, 0.1)';
                banner.style.borderColor = 'rgba(34, 197, 94, 0.3)';
                statusText.className = 'text-sm text-green-400 font-medium';
                statusText.textContent = `System Resilient - Survives ${mode.toUpperCase()} scenario`;
            } else {
                banner.style.background = 'rgba(34, 197, 94, 0.1)';
                banner.style.borderColor = 'rgba(34, 197, 94, 0.3)';
                statusText.className = 'text-sm text-green-400 font-medium';
                statusText.textContent = 'System Nominal - Full Redundancy';
            }
        }

        // ========== INIT ==========
        initScene();
        renderFacultyGrid();
        updateVisualization();
        animate();
    </script>
</body>
</html>
