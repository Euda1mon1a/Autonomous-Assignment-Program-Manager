#!/usr/bin/env python3
"""
Check for mixed AI assistant commits on the current Git branch.

This script helps prevent conflicts when using multiple AI coding assistants
(Claude Code, GitHub Copilot, Codex, etc.) on the same Git branch.

Usage:
    python scripts/check-ai-assistant-usage.py          # Basic check
    python scripts/check-ai-assistant-usage.py --strict # Exit non-zero on issues
    python scripts/check-ai-assistant-usage.py --commits 50  # Check more history
    python scripts/check-ai-assistant-usage.py --quiet  # Only show warnings
"""
import argparse
import re
import subprocess
import sys
from dataclasses import dataclass
from typing import Optional


# AI assistant detection patterns
AI_PATTERNS = {
    "claude": [
        r"\(claude\):",  # feat(claude):, fix(claude):
        r"claude code",
        r"generated by claude",
        r"co-authored-by:.*claude",
        r"\.claude$",  # Branch suffix
    ],
    "codex": [
        r"\(codex\):",  # feat(codex):, fix(codex):
        r"codex",
        r"co-authored-by:.*codex",
        r"\.codex$",  # Branch suffix
    ],
    "copilot": [
        r"\(copilot\):",
        r"github copilot",
        r"co-authored-by:.*copilot",
        r"\.copilot$",
    ],
    "cursor": [
        r"\(cursor\):",
        r"cursor ai",
        r"\.cursor$",
    ],
    "aider": [
        r"\(aider\):",
        r"aider",
        r"\.aider$",
    ],
}

# Human consolidation patterns (these "reset" the AI tracking)
HUMAN_PATTERNS = [
    r"^consolidate:",
    r"\(human\):",
    r"^merge:",
    r"^Merge pull request",
    r"^Merge branch",
    r"human review",
    r"manual fix",
]


@dataclass
class Commit:
    """Represents a Git commit."""

    hash: str
    author: str
    message: str
    detected_ai: Optional[str] = None
    is_human_consolidation: bool = False


def run_git_command(args: list[str]) -> tuple[int, str, str]:
    """Run a git command and return (returncode, stdout, stderr)."""
    result = subprocess.run(
        ["git"] + args, capture_output=True, text=True, timeout=30
    )
    return result.returncode, result.stdout, result.stderr


def get_current_branch() -> Optional[str]:
    """Get the current Git branch name."""
    code, stdout, _ = run_git_command(["branch", "--show-current"])
    if code != 0:
        return None
    return stdout.strip()


def get_recent_commits(count: int) -> list[Commit]:
    """Get the last N commits from the current branch."""
    # Format: hash|author|subject
    code, stdout, _ = run_git_command(
        ["log", f"-{count}", "--format=%H|%an|%s"]
    )
    if code != 0:
        return []

    commits = []
    for line in stdout.strip().split("\n"):
        if not line:
            continue
        parts = line.split("|", 2)
        if len(parts) == 3:
            commit = Commit(
                hash=parts[0][:8],
                author=parts[1],
                message=parts[2],
            )
            commits.append(commit)
    return commits


def detect_ai_in_commit(commit: Commit) -> Optional[str]:
    """Detect which AI assistant (if any) created this commit."""
    text = commit.message.lower()

    # Check for human consolidation first
    for pattern in HUMAN_PATTERNS:
        if re.search(pattern, text, re.IGNORECASE):
            commit.is_human_consolidation = True
            return None

    # Check for AI patterns
    for ai_name, patterns in AI_PATTERNS.items():
        for pattern in patterns:
            if re.search(pattern, text, re.IGNORECASE):
                commit.detected_ai = ai_name
                return ai_name

    return None


def analyze_commits(commits: list[Commit]) -> dict:
    """Analyze commits for AI mixing patterns."""
    # Detect AI in each commit
    for commit in commits:
        detect_ai_in_commit(commit)

    # Find sequences of AI commits
    ai_sequences = []
    current_sequence = []
    last_ai = None

    for commit in commits:
        if commit.is_human_consolidation:
            # Human consolidation resets the sequence
            if current_sequence:
                ai_sequences.append(current_sequence)
            current_sequence = []
            last_ai = None
        elif commit.detected_ai:
            if last_ai and last_ai != commit.detected_ai:
                # Different AI detected - this is a mixing point
                current_sequence.append(commit)
            elif commit.detected_ai:
                current_sequence.append(commit)
            last_ai = commit.detected_ai

    if current_sequence:
        ai_sequences.append(current_sequence)

    # Check for interleaving
    interleaved = []
    prev_ai = None
    for commit in commits:
        if commit.is_human_consolidation:
            prev_ai = None
            continue
        if commit.detected_ai:
            if prev_ai and prev_ai != commit.detected_ai:
                interleaved.append((commit, prev_ai, commit.detected_ai))
            prev_ai = commit.detected_ai

    # Get unique AIs used
    ais_used = set()
    for commit in commits:
        if commit.detected_ai:
            ais_used.add(commit.detected_ai)

    return {
        "commits_checked": len(commits),
        "ai_commits": [c for c in commits if c.detected_ai],
        "human_consolidations": [c for c in commits if c.is_human_consolidation],
        "ais_used": ais_used,
        "interleaved_points": interleaved,
        "has_mixing": len(interleaved) > 0,
    }


def check_uncommitted_changes() -> tuple[bool, str]:
    """Check for uncommitted changes."""
    code, stdout, _ = run_git_command(["status", "--porcelain"])
    if code != 0:
        return False, ""
    return bool(stdout.strip()), stdout.strip()


def print_report(analysis: dict, branch: str, quiet: bool = False) -> None:
    """Print the analysis report."""
    if not quiet:
        print(f"\n{'=' * 60}")
        print("  AI Assistant Usage Check")
        print(f"{'=' * 60}\n")

    # Branch info
    if not quiet:
        print(f"  Branch: {branch}")
        print(f"  Commits checked: {analysis['commits_checked']}")
        print()

    # AI commits found
    if analysis["ai_commits"]:
        if not quiet:
            print("  AI commits detected:")
            for commit in analysis["ai_commits"][:10]:
                ai = commit.detected_ai.upper()
                print(f"    [{ai:8}] {commit.hash} {commit.message[:50]}")
            if len(analysis["ai_commits"]) > 10:
                print(f"    ... and {len(analysis['ai_commits']) - 10} more")
            print()

    # Human consolidations
    if analysis["human_consolidations"] and not quiet:
        print("  Human consolidation commits:")
        for commit in analysis["human_consolidations"][:5]:
            print(f"    [HUMAN] {commit.hash} {commit.message[:50]}")
        print()

    # Main result
    if analysis["has_mixing"]:
        print("  " + "!" * 58)
        print("  !  WARNING: Mixed AI assistant commits detected!       !")
        print("  " + "!" * 58)
        print()
        print("  Interleaving points (where AI switched):")
        for commit, prev_ai, curr_ai in analysis["interleaved_points"][:5]:
            print(f"    {commit.hash}: {prev_ai} -> {curr_ai}")
            print(f"      \"{commit.message[:50]}\"")
        print()
        print("  Recommendation:")
        print("    1. Review the interleaved changes carefully")
        print("    2. Create a consolidation commit:")
        print('       git commit --allow-empty -m "consolidate: reviewed mixed AI changes"')
        print("    3. Then continue with your preferred AI")
        print()
    else:
        if not quiet:
            print("  " + "-" * 58)
        ais = ", ".join(analysis["ais_used"]) if analysis["ais_used"] else "None detected"
        print(f"  Status: OK - No problematic mixing detected")
        print(f"  AIs used: {ais}")
        if not quiet:
            print("  Safe to proceed with any AI assistant")
            print("  " + "-" * 58)

    print()


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Check for mixed AI assistant commits on the current Git branch",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scripts/check-ai-assistant-usage.py
  python scripts/check-ai-assistant-usage.py --strict
  python scripts/check-ai-assistant-usage.py --commits 50 --quiet

For more information, see:
  docs/development/ai-assistant-guardrails.md
        """,
    )
    parser.add_argument(
        "--strict",
        action="store_true",
        help="Exit with non-zero status if mixing is detected",
    )
    parser.add_argument(
        "--commits",
        type=int,
        default=20,
        help="Number of commits to check (default: 20)",
    )
    parser.add_argument(
        "--quiet",
        "-q",
        action="store_true",
        help="Only show warnings, suppress informational output",
    )
    args = parser.parse_args()

    # Check if we're in a git repo
    code, _, _ = run_git_command(["rev-parse", "--is-inside-work-tree"])
    if code != 0:
        print("Error: Not inside a Git repository")
        return 1

    # Get current branch
    branch = get_current_branch()
    if not branch:
        print("Error: Could not determine current branch")
        return 1

    # Check for uncommitted changes
    has_changes, changes = check_uncommitted_changes()
    if has_changes and not args.quiet:
        print("\n  Note: You have uncommitted changes:")
        for line in changes.split("\n")[:5]:
            print(f"    {line}")
        if changes.count("\n") > 5:
            print(f"    ... and {changes.count(chr(10)) - 5} more files")
        print()

    # Get and analyze commits
    commits = get_recent_commits(args.commits)
    if not commits:
        if not args.quiet:
            print("No commits found on this branch")
        return 0

    analysis = analyze_commits(commits)
    print_report(analysis, branch, args.quiet)

    # Return code
    if args.strict and analysis["has_mixing"]:
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())
